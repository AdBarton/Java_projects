import java.util.*;
 
public class main
{
    private static Scanner sc = new Scanner(System.in);
 
    private static HashMap<Integer, int[]> mines = new HashMap<>(); //obsahuje ve value souradnice x a y jako pole int[]
    private static HashMap<Integer, int[]> clicks = new HashMap<>();
 
    private static char[][] matrixGame;
 
    private static int nrOfRow;
    private static int nrOfColumn;
 
    public static void main(String[] args)
    {
        nrOfRow = sc.nextInt();
        nrOfColumn = sc.nextInt();
        int nrOfMine = sc.nextInt();
 
        char[][] matrix = new char[nrOfRow][nrOfColumn];
        matrixGame = new char[nrOfRow][nrOfColumn];
 
        for (int i = 0; i < nrOfMine; i++) {
            mines.put(i, new int[]{sc.nextInt(), sc.nextInt()});
        }
 
        int nrOfClick = sc.nextInt();
 
        for (int i = 0; i < nrOfClick; i++) {
            clicks.put(i, new int[]{sc.nextInt(), sc.nextInt()});
        }
 
        //zaplneni pole : mina = *, kliknuti = o, ostatni = ?, odkyti = .
        for (int r = 0; r < nrOfRow; r++) {
            for (int c = 0; c < nrOfColumn; c++) {
                if (isMine(r, c)) {
                    matrix[r][c] = '*';
                    matrixGame[r][c] = '?';
                }
                else if (isClicked(r, c)) {
                    matrix[r][c] = 'o';
                    // matrixGame[r][c] = '.';
                    matrixGame[r][c] = '?';
                }
                else {
                    matrix[r][c] = '?';
                    matrixGame[r][c] = '?';
                }
                System.out.format("%c ", matrix[r][c]);
            }
            System.out.println();
        }
        System.out.println();
 
 
        // prace s matrixGame
        for (int[] values : clicks.values()) {
            if (isSafe(values[0], values[1]) && !isOpen(values[0], values[1])) {
                open(values[0], values[1]);
            }
        }
 
        for (int r = 0; r < nrOfRow; r++) {
            for (int c = 0; c < nrOfColumn; c++) {
                System.out.format("%c ", matrixGame[r][c]);
            }
            System.out.println();
        }
    }
 
    /**
     * @param row    souradnice x
     * @param column souradnice y
     */
    private static void open(int row, int column)
    {
        matrixGame[row][column] = '.';
 
        //neighbours
        // je mozny i zapis : if (isValid(row - 1, column) && isSafe(row, column) && !isOpen(row, column)) open(row - 1, column);
        int[] n1 = {row, column - 1};
        int[] n2 = {row, column + 1};
 
        int[] n3 = {row - 1, column + 1};
        int[] n4 = {row - 1, column};
        int[] n5 = {row - 1, column - 1};
 
        int[] n6 = {row + 1, column + 1};
        int[] n7 = {row + 1, column};
        int[] n8 = {row + 1, column - 1};
 
        int[][] neighbours = {n1, n2, n3, n4, n5, n6, n7, n8};
 
        for (int[] neighbour : neighbours) {
            if (isValid(neighbour[0], neighbour[1]) &&
                    isSafe(neighbour[0], neighbour[1]) &&
                    !isOpen(neighbour[0], neighbour[1])) {
                open(neighbour[0], neighbour[1]);
            }
        }
    }
 
    /**
     * @param row    souradnice x
     * @param column souradnice y
     * @return true jestli  matrixGame[row][column] uz otevrena, false jestli ne
     */
    private static boolean isOpen(int row, int column)
    {
        return (matrixGame[row][column] == '.');
    }
 
    /**
     * @param row    souradnice x
     * @param column souradnice y
     * @return true jestli row >= 0 && row < size of matrix + column >= 0 && column < size of matrix
     */
    private static boolean isValid(int row, int column)
    {
        return (row >= 0) && (row < nrOfRow) &&
                (column >= 0) && (column < nrOfColumn);
    }
 
    /**
     * @param row    souradnice x
     * @param column souradnice y
     * @return true, jestli neni kolem pole zadna mina, false jestli je
     */
    private static boolean isSafe(int row, int column)
    {
        return !(
                isMine(row, column) || isMine(row, column - 1) || isMine(row - 1, column) ||
                        isMine(row, column + 1) || isMine(row + 1, column) ||
                        isMine(row - 1, column - 1) || isMine(row + 1, column - 1) ||
                        isMine(row - 1, column + 1) || isMine(row + 1, column + 1)
        );
    }
 
    /**
     * @param x souradnice x
     * @param y souradnice x
     * @return true jesli pole [x][y] je rozkliknuto
     */
    private static boolean isClicked(int x, int y)
    {
        for (int[] values : clicks.values()) {
            if (Arrays.equals(values, new int[]{x, y})) {
                return true;
            }
        }
 
        return false;
    }
 
    /**
     * @param x souradnice x
     * @param y souradnice x
     * @return true jesli na pole [x][y] je mina
     */
 
    private static boolean isMine(int x, int y)
    {
        for (int[] values : mines.values()) {
            if (Arrays.equals(values, new int[]{x, y})) {
                return true;
            }
        }
        return false;
    }
}